<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <link href="https://fonts.googleapis.com/css?family=Bungee+Inline&display=swap" rel="stylesheet" />
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=1" name="viewport" />
  <title>Pax Consola</title>

  <link href="/static/paxconsola.css" rel="stylesheet">

  <script type="text/javascript"
    src="https://unpkg.com/responsive-gamepad@1.2.1/dist/responsive-gamepad.umd.js"></script>

  <link data-trunk rel="copy-dir" href="static" />
  <link data-trunk rel="copy-dir" href="build/crossconsola" />
  <link data-trunk rel="copy-dir" href="build/workers" />

  <link data-trunk rel="copy-dir" href="../doc/book" />

  <link data-trunk rel="copy-file" href="static/favicon.ico" />

  <link data-trunk rel="rust" data-bin="app" />
</head>

<body>
  <h1 style="font-family: Helvetica, Arial; color: #333; margin: 1em">Loading Pax Consola...</h1>

  <script>

    // // Wrapper around RGBDK
    // window.CompileGameboy = (filenamevaluelist) => {
    //   const files = new Map();
    //   while (filenamevaluelist.length) {
    //     const contents = new Uint8Array(filenamevaluelist.pop());
    //     const name = new TextDecoder("utf-8").decode(new Uint8Array(filenamevaluelist.pop()));
    //     console.info('[rgbasm] writing file', name, 'with', new TextDecoder("utf-8").decode(contents));
    //     files.set(name, contents);
    //   }

    //   function populate(FS) {
    //     try {
    //       for (const name of files.keys()) {
    //         // mkdir -p
    //         const cache = [];
    //         for (const segment of name.split('/').slice(0, -1)) {
    //           cache.push(segment);
    //           try {
    //             FS.mkdir(cache.join('/'));
    //           } catch (e) {
    //             // noop
    //           }
    //         }

    //         FS.writeFile(name, files.get(name));
    //       }
    //     } catch (e) {
    //       console.error(e);
    //     }
    //   }

    //   return new Promise((resolve, reject) => {
    //     const MAIN = 'kernel/bank0.asm';
    //     const OUT = 'bank0.obj';

    //     const stdout = [];
    //     const stderr = [];

    //     const settings = {
    //       arguments: ['-E', '-o', OUT, MAIN],
    //       onExit: function (errCode) {
    //         // Call asynchronously.
    //         if (errCode > 0) {
    //           setTimeout(reject.bind(null, { stdout, stderr }), 0);
    //         } else {
    //           // Copy artifacts
    //           files.set(OUT, new Uint8Array(settings.FS.readFile(OUT)));

    //           setTimeout(resolve.bind(null, { stdout, stderr }), 0);
    //         }
    //       },
    //       print: function () {
    //         stdout.push(Array.from(arguments).join(' '));
    //       },
    //       printErr: function () {
    //         stderr.push(Array.from(arguments).join(' '));
    //       },
    //       totalDependencies: 0,
    //     };
    //     RGBASM(settings).then(_ => {
    //       populate(settings.FS);
    //     });
    //   }).then(result => new Promise((resolve, reject) => {
    //     const OBJ_NAME = 'paxconsola';
    //     const OBJS_NAME = 'bank0';

    //     const stdout = [];
    //     const stderr = [];

    //     const settings = {
    //       arguments: [`-m${OBJ_NAME}.map`, `-n${OBJ_NAME}.sym`, `-o${OBJ_NAME}.gb`, `${OBJS_NAME}.obj`],
    //       onExit: function (errCode) {
    //         // Call asynchronously.
    //         if (errCode > 0) {
    //           setTimeout(reject.bind(null, { stdout, stderr }), 0);
    //         } else {
    //           const game = settings.FS.readFile(`${OBJ_NAME}.gb`);
    //           console.log('COMPILATION RESULT GAMEBOY:', game);
    //           setTimeout(resolve.bind(null, { stdout, stderr, game, fs: settings.FS }), 0);
    //         }
    //       },
    //       print: function () {
    //         stdout.push(Array.from(arguments).join(' '));
    //       },
    //       printErr: function () {
    //         stderr.push(Array.from(arguments).join(' '));
    //       },
    //       totalDependencies: 0,
    //       FS: result.fs,
    //     };
    //     RGBLINK(settings).then(_ => {
    //       populate(settings.FS);
    //       console.log('RGBLINK READY');
    //     })
    //   }))
    // };

    window.PlayGameboy = (binary) => {
      const loadWasmBoy = async () => {
        // await mountPromise;
        const wasmBoyCanvas = document.querySelector('#GAMEBOY_CANVAS');
        // const EmbedPlugin = {
        //     name: 'EmbedPlugin',
        //     saveState: saveStateObject => {
        //         if (wasmBoyCanvas) {
        //             saveStateObject.screenshotCanvasDataURL = wasmBoyCanvas.toDataURL();
        //         }
        //     },
        //     play: () => isPlaying.set(true),
        //     pause: () => {
        //         isPlaying.set(false);
        //         setStatus('Paused', -1);
        //     }
        // };

        await WasmBoy.WasmBoy.config({
          isGbcEnabled: false,
          isGbcColorizationEnabled: false,
          isAudioEnabled: false,
          gameboyFrameRate: 60,
          maxNumberOfAutoSaveStates: 3
        });
        await WasmBoy.WasmBoy.setCanvas(wasmBoyCanvas);
        // WasmBoy.addPlugin(EmbedPlugin);
        await WasmBoy.WasmBoy.loadROM(binary);
        await WasmBoy.WasmBoy.play();
      }
      const wasmBoyPromise = loadWasmBoy().catch(error => {
        console.error(error);
        throw error;
      });
      // isPlaying.subscribe(async (value) => {
      //     if (!WasmBoy.isPlaying() && value) {
      //         await WasmBoy.play();
      //     } else if (WasmBoy.isPlaying() && !value) {
      //         await WasmBoy.pause();
      //     }
      // });
      // saveState.subscribe(() => {
      //     if ($isStarted && $isLoaded) {
      //         WasmBoy.saveState().then(() => {
      //             WasmBoy.play();
      //             setStatus('State Saved!');
      //         }).catch(() => {
      //             setStatus('Error saving the state...')
      //         });
      //     }
      // });
    };

    // Simple example, should work
    // fetch('/test.asm').then(res => res.arrayBuffer())
    //   .then(res => CompileGameboy([['kernel/bank0.asm', new Uint8Array(res)]]))
    //   .then(({ game }) => {
    //     console.log('success', game);
    //     return PlayGameboy(game);
    //   }).catch(err => {
    //     console.error('Error Configuring WasmBoy:', err);
    //   });

  // </script>

  <script>
    const getLoaderScript = document.createElement('script')
    getLoaderScript.src = 'https://www.typescriptlang.org/js/vs.loader.js'
    getLoaderScript.async = true
    getLoaderScript.onload = () => {
      require.config({
        paths: { 'vs': 'https://unpkg.com/monaco-editor@0.20.0/min/vs' },
        // This is something you need for monaco to work
        ignoreDuplicateModules: ['vs/editor/editor.main'],
      });

      // Before loading vs/editor/editor.main, define a global MonacoEnvironment that overwrites
      // the default worker url location (used when creating WebWorkers). The problem here is that
      // HTML5 does not allow cross-domain web workers, so we need to proxy the instantiation of
      // a web worker through a same-domain script
      window.MonacoEnvironment = {
        getWorkerUrl: function (workerId, label) {
          return `data:text/javascript;charset=utf-8,${encodeURIComponent(`
      self.MonacoEnvironment = {
        baseUrl: 'https://unpkg.com/monaco-editor@0.20.0/min/'
      };
      importScripts('https://unpkg.com/monaco-editor@0.20.0/min/vs/base/worker/workerMain.js');`
          )}`;
        }
      };

      require([
        'vs/editor/editor.main',
      ], function () {
        let handle = setInterval(() => {
          if (!document.getElementById("MONACO_TEXTAREA")) {
            return;
          }

          const editor = monaco.editor.create(document.getElementById("MONACO_INJECT"), {
            value: document.getElementById("MONACO_TEXTAREA").value,
            language: "scheme",
            fontSize: 14,
            theme: "monokai"
          });

          // Awkward resize handler to work around rendering in a flexbox.
          window.addEventListener('resize', () => {
            requestAnimationFrame(() => {
              editor.layout({
                width: 10, height: 10,
              });
              editor.layout();
            })
          });

          editor.getModel().onDidChangeContent(() => {
            document.getElementById("MONACO_TEXTAREA").value = editor.getValue();
            document.getElementById("MONACO_TEXTAREA").dispatchEvent(new InputEvent('input'));
          });



          clearInterval(handle);
        }, 100);
      });
    };
    document.body.appendChild(getLoaderScript)
  </script>

</body>

</html>

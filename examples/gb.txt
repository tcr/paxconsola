
$C020 constant last-key
$9800 constant graphics

variable temp
variable initialized
variable ram_x
variable ram_y
variable frame


: drop    if then ;
: 2drop   + drop ;

: swap   >r temp ! r> temp @ ;
: over   >r temp ! temp @ r> temp @ ;
: rot    >r swap r> swap ;

\ note: must preserve return address!
: r@   r> r> temp ! temp @ >r temp @ swap >r ;

: dup    temp ! temp @ temp @ ;
: 2dup   over over ;
: ?dup   temp ! temp @ if temp @ temp @ then ;

: cells dup + ;

: invert   -1 nand ;
: negate   invert 1 + ;
: -        negate + ;

: 1+   1 + ;
: 1-   -1 + ;
: +!   dup >r @ + r> ! ;
: 0=   if 0 else -1 then ;
: =    - 0= ;
: <>   = 0= ;
: ==   - 0= ;

: or   invert swap invert nand ;
: xor   2dup nand 1+ dup + + + ;
: and   nand invert ;

\ return stack pops off index, then limit, reverse of initial stack order
\ compare, if equal then cleanup and return 1, else increase index, push, return 0
\ note: must preserve return address!
: loopimpl r> r> r> 1+ 2dup = if 2drop 1 else >r >r 0 then swap >r ;
: -loopimpl r> r> rot r> swap - 2dup = if 2drop 1 else >r >r 0 then swap >r ;

\ note: must preserve return address!
: i r> r> r> temp ! temp @ >r >r >r temp @ ;
: j r> r> r> r> r> temp ! temp @ >r >r >r >r >r temp @ ;

: * >r 0 r> 0 do over + loop swap drop ;

\ end stdlib






\ start of snake.txt

variable snake-x-head
500 cells allot

variable snake-y-head
500 cells allot

variable apple-x
variable apple-y

37 constant left
38 constant up
39 constant right
40 constant down

20 constant width
18 constant height

variable direction
variable length

: snake-x ( offset -- address )
  cells snake-x-head + ;

: snake-y ( offset -- address )
  cells snake-y-head + ;

: convert-x-y ( x y -- offset )  32 * + ;
: draw ( color x y -- )  convert-x-y graphics + c! ;
: draw-white ( x y -- )  0 rot rot draw ;
: draw-black ( x y -- )  23 rot rot draw ;

: draw-walls
  width 0 do
    i 0 draw-black
    i height 1 - draw-black
  loop
  height 0 do
    0 i draw-black
    width 1 - i draw-black
  loop ;

: initialize-snake
  4 length !
  length @ 1 + 0 do
    8 i - i snake-x !
    8 i snake-y !
  loop
  right direction ! ;

: set-apple-position apple-x ! apple-y ! ;

: initialize-apple  2 2 set-apple-position ;

: initialize
  width 0 do
    height 0 do
      j i draw-white
    loop
  loop
  draw-walls
  initialize-snake
  initialize-apple
  8 ram_x !
  6 ram_y ! ;

\ Initialize only once
initialized @ 0= if initialize then
1 initialized !


\ game runtime

: draw-snake
  length @ 0 do
    i snake-x @ i snake-y @ draw-black
  loop
  length @ snake-x @
  length @ snake-y @
  draw-white ;

: draw-apple
  apple-x @ apple-y @ draw-black ;

: check-collision ( -- flag )
  \ get current x/y position
  ram_x @ ram_y @

  \ get color at current position
  convert-x-y graphics + c@

  \ leave boolean flag on stack
  0= if else begin 0 until then ;

: clear ram_x @ ram_y @ draw-white ;

\ every frame ?
ram_x @ ram_y @ draw-black

\ frameskip
frame @ 1+ dup frame !
4 = if 0 frame !



draw-snake
draw-apple

last-key @
  left over = if ram_x @ 1- dup ram_x ! ram_y check-collision draw-black else
  up over    = if ram_x ram_y @ 1- dup ram_y ! check-collision draw-black else
  right over  = if ram_x @ 1+ dup ram_x ! ram_y check-collision draw-black else
  down over = if ram_x ram_y @ 1+ dup ram_y ! check-collision  draw-black
  then then then then

\ end frameskip
then
















(

: move-right 23 graphics 67 + c! ;
: move-left 21 graphics 65 + c! ;
: move-up 22 graphics 34 + c! ;
: move-down 24 graphics 98 + c! ;

last-key @
  left over = if move-left else
  up over    = if move-up else
  right over  = if move-right else
  down over = if move-down
  then then then then

)
